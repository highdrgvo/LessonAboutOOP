package ru.serple.data;

public abstract class Card {  // Класс - шаблон для объекта. Класс определяет, как объект будет выглядеть и какими функциями обладать. Каждый объект является объектом какого-то класса. По сути — это шаблон для всех карт, которые мы создадим в будущем.

    // Абстракция - это принцип ООП, согласно которому при проектировании классов и создании объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные.
    // Например, если будем проектировать класс SchoolTeacher — школьный учитель — вряд ли понадобится характеристика «рост»
    // Так вот, абстрактный класс — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих классов.
    // Эту заготовку нельзя использовать в готовом виде — слишком «сырая».
    // Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.
    // Первое и главное — экземпляр абстрактного класса создать нельзя. Мы не можем сделать так в Main классе: Car car = new Car();
    // Абстрактные классы избавляют нас от «просто объектов». Они дают нам базовое состояние и поведение.
    // Например, у всех машин должна быть модель, цвет и максимальная скорость, а еще они должны уметь газовать и тормозить.
    // Вот и все. Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы.

    // Если класс помечаем абстрактным, то не можем от него наследоваться. С этим классом могут работать только наследники (MasterCard, MirCard и т д)

    // Инкапсуляция - это механизм, который объединяет данные (поля) и методы (функции) для работы с ними в одном классе,
    // а также ограничивает прямой доступ к внутреннему состоянию объекта извне.
    // Основные идеи:
    //  1. Сокрытие данных – внутренние поля класса не должны быть доступны напрямую извне.
    //  2. Контролируемый доступ – взаимодействие с данными происходит через публичные методы (геттеры, сеттеры и другие).
    //  3. Защита от некорректных изменений – класс сам контролирует, как и при каких условиях можно менять его состояние.

    // Как реализуется?
    //   - private / protected модификаторы доступа (в таких языках, как Java, C++, C#)
    //   - публичные методы (get и set) для безопасного изменения полей.

    // Модификаторы доступа
    // Private - доступен только в текущем классе
    // Без модификатора - доступен в текущем классе и в том же пакете
    // Protected - доступен в текущем классе, в том же пакете и в подклассах (вне пакета)
    // Public - доступен в текущем классе, в том же пакете, в подклассах (вне пакета), во всем проекте

    protected String cardHolder; // у каждого объекта класса Card будет название владельца карты и баланс
    protected int balance;
    protected String cardNumber; // String, int - это тип данных полей объекта.
    protected PaymentSystem paymentSystem;

    public String getCardHolder() {
        return cardHolder;
    }

    public void setCardHolder(String cardHolder) {
        this.cardHolder = cardHolder;
    }

    public int getBalance() {
        return balance;
    }

    public void setBalance(int balance) {
        if (balance < 0)
            return;
        else {
            System.out.println("added balance: " + balance);
            this.balance = balance;
        }
    }

    public String getCardNumber() {
        return cardNumber;
    }

    public void setCardNumber(String cardNumber) {
        if (cardNumber.length() != 16) {
            return;
        }
        this.cardNumber = cardNumber;
    }

    public void setPaymentSystem(PaymentSystem paymentSystem) {
        this.paymentSystem = paymentSystem;
    }

    // Мы написали структуру данных (пока только какие поля будут), описывающую банковскую карточку

    // Наследование в Java - это механизм, который позволяет классу наследовать свойства (поля) и методы другого класса (родительского класса).
    // В Java наследование достигается с помощью ключевого слова extends.
    // В нашем примере классы MasterCard, MirCard наследуют класс Card.

    // Конструктор. Создавая объект карты, конструктор будет просить название карты, после чего сохранит значение в public PaymentSystem paymentSystem.
    // Конструктор создает своеобразный “каркас” класса, которому каждый новый объект класса должен соответствовать.
    // Он похож на обычный метод, но у него нет типа возвращаемого значения.
    // "this" по-английски — "этот, этого". Это слово указывает на конкретный предмет.
    // Код в конструкторе: платежную систему для карточки, которую мы создаем = аргументу paymentSystem, который указан в конструкторе.
    // Теперь нельзя создать карточку без paymentSystem.

    public Card(PaymentSystem paymentSystem) {
        this.paymentSystem = paymentSystem;
    }

    public PaymentSystem getPaymentSystem() {
        return paymentSystem;
    }

    protected boolean isBalanceGreaterOrEqualThan(int amount) {
        return balance >= amount;
    }

    // Return используется для возврата значения из метода (если метод не void). В данном случае он вернет true или false

    public void payInCountry(Country country,  int amount) {
        if(isCountryValidForThisCard(country) && isBalanceGreaterOrEqualThan(amount)) {
            balance = balance - amount;
            System.out.println("Accepted");
        }
    }

    // Void указывает, что метод не возвращает никакого значения

    // Метод - это функционал класса; то, что объекты этого класса умеют делать. Бизнес-логика, то полезное, что может делать программа, описывается в методах. Метод - это часть объекта.
    // Метод payInCountry говорит о том, что у объекта появилась возможность вызвать вот такое действие. И в country будет передать страну из enum класса, который создали.

    protected abstract boolean isCountryValidForThisCard(Country country);
}
