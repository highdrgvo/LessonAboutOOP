package ru.serple.data;

public abstract class Card {  // Класс - шаблон для объекта. Класс определяет, как объект будет выглядеть и какими функциями обладать. Каждый объект является объектом какого-то класса. По сути — это шаблон для всех карт, которые мы создадим в будущем.

    // Абстракция - это принцип ООП, согласно которому при проектировании классов и создании объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные.
    // Например, если будем проектировать класс SchoolTeacher — школьный учитель — вряд ли понадобится характеристика «рост»
    // Так вот, абстрактный класс — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих классов.
    // Эту заготовку нельзя использовать в готовом виде — слишком «сырая».
    // Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.
    // Первое и главное — экземпляр абстрактного класса создать нельзя. Мы не можем сделать так в Main классе: Car car = new Car();
    // Абстрактные классы избавляют нас от «просто объектов». Они дают нам базовое состояние и поведение.
    // Например, у всех машин должна быть модель, цвет и максимальная скорость, а еще они должны уметь газовать и тормозить.
    // Вот и все. Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы.

    // Если класс помечаем абстрактным, то не можем от него наследоваться. С этим классом могут работать только наследники (MasterCard, MirCard и т д)

    // В программировании есть два распространенных понятия — инкапсуляция и сокрытие.
    // Инкапсуляция - объединение данных и методов работы с этими данными в одной упаковке («капсуле»).
    // В Java в роли упаковки-капсулы выступает класс. Класс содержит в себе и данные (поля класса), и методы для работы с этими данными.
    // Сокрытие.
    // Как же так получается, что мы пользуемся всякими сложными механизмами без понимания, как они устроены и на чем основана их работа?
    // Все просто: их создатели предоставили простой и удобный интерфейс.
    // На автомате с газировкой интерфейс — это кнопки на панели. Нажав одну кнопку, ты выбираешь объем стакана.
    // Нажав вторую, выбираешь сироп. Третья отвечает за добавление льда. И это все, что тебе нужно сделать.
    // Неважно, как именно автомат устроен внутри. Главное — он устроен так, что для получения газировки пользователю нужно нажать три кнопки.
    // Именно в этом заключается суть сокрытия. Все «внутренности» программы скрываются от пользователя.
    // Для него эта информация является лишней, ненужной. Пользователю необходим конечный результат, а не внутренний процесс.
    // в Java есть еще сокрытие данных.
    // С сокрытием данных нам помогают: модификатормы доступа (private, protected, package default) и геттеры и сеттеры.
    // Если привести пример из жизни, private — это все процессы, происходящие внутри телевизора, когда он работает,
    // а public — это кнопки на пульте телевизора, с помощью которых пользователь может им управлять.
    // При этом ему не нужно знать как устроен телевизор и за счет чего он работает.

    // Модификаторы доступа
    // Private - доступен только в текущем классе
    // Без модификатора - доступен в текущем классе и в том же пакете
    // Protected - доступен в текущем классе, в том же пакете и в подклассах (вне пакета)
    // Public - доступен в текущем классе, в том же пакете, в подклассах (вне пакета), во всем проекте

    protected String cardHolder; // у каждого объекта класса Card будет название владельца карты и баланс
    protected int balance;
    protected String cardNumber; // String, int - это тип данных полей объекта.
    protected PaymentSystem paymentSystem;

    public String getCardHolder() {
        return cardHolder;
    }

    public void setCardHolder(String cardHolder) {
        this.cardHolder = cardHolder;
    }

    public int getBalance() {
        return balance;
    }

    public void setBalance(int balance) {
        if (balance < 0)
            return;
        else {
            System.out.println("added balance: " + balance);
            this.balance = balance;
        }
    }

    public String getCardNumber() {
        return cardNumber;
    }

    public void setCardNumber(String cardNumber) {
        if (cardNumber.length() != 16) {
            return;
        }
        this.cardNumber = cardNumber;
    }

    public void setPaymentSystem(PaymentSystem paymentSystem) {
        this.paymentSystem = paymentSystem;
    }

    // Мы написали структуру данных (пока только какие поля будут), описывающую банковскую карточку

    // Наследование в Java - это механизм, который позволяет классу наследовать свойства (поля) и методы другого класса (родительского класса). В Java наследование достигается с помощью ключевого слова extends.
    // В нашем примере классы MasterCard, MirCard наследуют класс Card.


    // Это конструктор. Создавая объект карты, конструктор будет просить название карты, после чего сохранит значение в public PaymentSystem paymentSystem.
    // Конструктор создает своеобразный “каркас” класса, которому каждый новый объект класса должен соответствовать.
    // Он похож на обычный метод, но у него нет типа возвращаемого значения.
    // "this" по-английски — "этот, этого". Это слово указывает на конкретный предмет.
    // Код в конструкторе: платежную систему для карточки, которую мы создаем = аргументу paymentSystem, который указан в конструкторе.
    // Теперь нельзя создать карточку без paymentSystem.

    public Card(PaymentSystem paymentSystem) {
        this.paymentSystem = paymentSystem;
    }

    public PaymentSystem getPaymentSystem() {
        return paymentSystem;
    }

    protected boolean isBalanceGreaterOrEqualThan(int amount) {
        return balance >= amount;
    }

    // Return используется для возврата значения из метода (если метод не void). В данном случае он вернет true или false

    public void payInCountry(Country country,  int amount) {
        if(isCountryValidForThisCard(country) && isBalanceGreaterOrEqualThan(amount)) {
            balance = balance - amount;
            System.out.println("Accepted");
        }
    }

    // Void указывает, что метод не возвращает никакого значения

    // это функционал класса; то, что объекты этого класса умеют делать. Бизнес-логика, то полезное, что может делать программа, описывается в методах. Метод - это часть объекта.
    // Метод payInCountry говорит о том, что у объекта появилась возможность вызвать вот такое действие. И в country будет передать страну из enum класса, который создали.

    protected abstract boolean isCountryValidForThisCard(Country country);
}
